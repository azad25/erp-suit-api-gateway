package resolver

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.78

import (
	"context"
	"fmt"
	"time"

	"erp-api-gateway/api/graphql/generated"
	"erp-api-gateway/api/graphql/model"
	"erp-api-gateway/internal/interfaces"
	authpb "erp-api-gateway/proto/gen/auth"
)

// Login is the resolver for the login field.
func (r *mutationResolver) Login(ctx context.Context, input model.LoginInput) (*model.AuthResponse, error) {
	// Call auth service via gRPC
	authClient, err := r.GRPCClient.AuthService(ctx)
	if err != nil {
		r.Logger.Error("Failed to get auth client", map[string]interface{}{
			"error": err,
			"email": input.Email,
		})
		return nil, fmt.Errorf("authentication service unavailable")
	}
	
	resp, err := authClient.Login(ctx, &authpb.LoginRequest{
		Email:      input.Email,
		Password:   input.Password,
		RememberMe: input.RememberMe != nil && *input.RememberMe,
	})

	if err != nil {
		r.Logger.Error("Login gRPC call failed", map[string]interface{}{
			"error": err,
			"email": input.Email,
		})
		return nil, fmt.Errorf("authentication service unavailable")
	}

	if !resp.Success {
		r.Logger.Info("Login failed", map[string]interface{}{
			"email":   input.Email,
			"message": resp.Message,
		})
		return nil, fmt.Errorf("login failed: %s", resp.Message)
	}

	// Publish login event to Kafka
	go func() {
		event := interfaces.Event{
			Type:   "user.logged_in",
			UserID: resp.Data.User.Id,
			Data: map[string]interface{}{
				"email":      resp.Data.User.Email,
				"login_time": time.Now(),
			},
			Timestamp: time.Now(),
		}
		if err := r.KafkaProducer.PublishUserEvent(context.Background(), resp.Data.User.Id, event); err != nil {
			r.Logger.Error("Failed to publish login event", map[string]interface{}{
				"error":   err,
				"user_id": resp.Data.User.Id,
			})
		}
	}()

	return &model.AuthResponse{
		User:         convertProtoUserToGraphQL(resp.Data.User),
		AccessToken:  resp.Data.AccessToken,
		RefreshToken: resp.Data.RefreshToken,
		ExpiresIn:    int(resp.Data.ExpiresIn),
	}, nil
}

// Register is the resolver for the register field.
func (r *mutationResolver) Register(ctx context.Context, input model.RegisterInput) (*model.AuthResponse, error) {
	// Call auth service via gRPC
	authClient, err := r.GRPCClient.AuthService(ctx)
	if err != nil {
		r.Logger.Error("Failed to get auth client", map[string]interface{}{
			"error": err,
			"email": input.Email,
		})
		return nil, fmt.Errorf("authentication service unavailable")
	}
	
	resp, err := authClient.Register(ctx, &authpb.RegisterRequest{
		FirstName:            input.FirstName,
		LastName:             input.LastName,
		Email:                input.Email,
		Password:             input.Password,
		PasswordConfirmation: input.Password, // GraphQL schema doesn't have confirmation field
	})

	if err != nil {
		r.Logger.Error("Register gRPC call failed", map[string]interface{}{
			"error": err,
			"email": input.Email,
		})
		return nil, fmt.Errorf("authentication service unavailable")
	}

	if !resp.Success {
		r.Logger.Info("Registration failed", map[string]interface{}{
			"email":   input.Email,
			"message": resp.Message,
		})
		return nil, fmt.Errorf("registration failed: %s", resp.Message)
	}

	// Publish registration event to Kafka
	go func() {
		event := interfaces.Event{
			Type:   "user.registered",
			UserID: resp.Data.User.Id,
			Data: map[string]interface{}{
				"email":             resp.Data.User.Email,
				"first_name":        resp.Data.User.FirstName,
				"last_name":         resp.Data.User.LastName,
				"registration_time": time.Now(),
			},
			Timestamp: time.Now(),
		}
		if err := r.KafkaProducer.PublishUserEvent(context.Background(), resp.Data.User.Id, event); err != nil {
			r.Logger.Error("Failed to publish registration event", map[string]interface{}{
				"error":   err,
				"user_id": resp.Data.User.Id,
			})
		}
	}()

	return &model.AuthResponse{
		User:         convertProtoUserToGraphQL(resp.Data.User),
		AccessToken:  resp.Data.AccessToken,
		RefreshToken: resp.Data.RefreshToken,
		ExpiresIn:    int(resp.Data.ExpiresIn),
	}, nil
}

// Logout is the resolver for the logout field.
func (r *mutationResolver) Logout(ctx context.Context) (*model.MutationResponse, error) {
	// Get user ID from context
	userID, exists := ctx.Value("user_id").(string)
	if !exists {
		return &model.MutationResponse{
			Success: false,
			Message: "User not authenticated",
		}, nil
	}

	// For logout, we would typically revoke the token
	// This would require getting the token from the Authorization header
	// For now, just log the logout event

	// Publish logout event to Kafka
	go func() {
		event := interfaces.Event{
			Type:   "user.logged_out",
			UserID: userID,
			Data: map[string]interface{}{
				"logout_time": time.Now(),
			},
			Timestamp: time.Now(),
		}
		if err := r.KafkaProducer.PublishUserEvent(context.Background(), userID, event); err != nil {
			r.Logger.Error("Failed to publish logout event", map[string]interface{}{
				"error":   err,
				"user_id": userID,
			})
		}
	}()

	r.Logger.Info("User logged out", map[string]interface{}{
		"user_id": userID,
	})

	return &model.MutationResponse{
		Success: true,
		Message: "Successfully logged out",
	}, nil
}

// RefreshToken is the resolver for the refreshToken field.
func (r *mutationResolver) RefreshToken(ctx context.Context, refreshToken string) (*model.AuthResponse, error) {
	// Call auth service via gRPC
	authClient, err := r.GRPCClient.AuthService(ctx)
	if err != nil {
		r.Logger.Error("Failed to get auth client", map[string]interface{}{
			"error": err,
		})
		return nil, fmt.Errorf("authentication service unavailable")
	}
	
	resp, err := authClient.RefreshToken(ctx, &authpb.RefreshTokenRequest{
		RefreshToken: refreshToken,
	})

	if err != nil {
		r.Logger.Error("RefreshToken gRPC call failed", map[string]interface{}{
			"error": err,
		})
		return nil, fmt.Errorf("authentication service unavailable")
	}

	if !resp.Success {
		r.Logger.Info("Token refresh failed", map[string]interface{}{
			"message": resp.Message,
		})
		return nil, fmt.Errorf("token refresh failed: %s", resp.Message)
	}

	// For refresh token, we need to get user info separately
	// since the refresh response only contains tokens
	return &model.AuthResponse{
		User:         &model.User{}, // Would need to fetch user info separately
		AccessToken:  resp.Data.AccessToken,
		RefreshToken: resp.Data.RefreshToken,
		ExpiresIn:    int(resp.Data.ExpiresIn),
	}, nil
}

// Mutation returns generated.MutationResolver implementation.
func (r *Resolver) Mutation() generated.MutationResolver { return &mutationResolver{r} }

type mutationResolver struct{ *Resolver }
