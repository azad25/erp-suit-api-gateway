package resolver

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.78

import (
	"context"
	"encoding/json"
	"fmt"

	"erp-api-gateway/api/graphql/generated"
	"erp-api-gateway/api/graphql/model"
)

// UserNotifications is the resolver for the userNotifications field.
func (r *subscriptionResolver) UserNotifications(ctx context.Context) (<-chan *model.Notification, error) {
	// Get user ID from context
	userID, exists := ctx.Value("user_id").(string)
	if !exists {
		return nil, fmt.Errorf("user not authenticated")
	}

	// Create channel for notifications
	notificationChan := make(chan *model.Notification, 10)

	// Subscribe to Redis Pub/Sub channel for user notifications
	channelName := fmt.Sprintf("notifications:%s", userID)
	pubsub, err := r.RedisClient.Subscribe(ctx, channelName)
	if err != nil {
		return nil, fmt.Errorf("failed to subscribe to notifications: %w", err)
	}

	go func() {
		defer close(notificationChan)
		defer pubsub.Close()

		for {
			select {
			case <-ctx.Done():
				r.Logger.Info("User notification subscription cancelled", map[string]interface{}{
					"user_id": userID,
				})
				return
			case msg := <-pubsub.Channel():
				if msg == nil {
					continue
				}

				// Parse the notification message
				var notification model.Notification
				if err := json.Unmarshal([]byte(msg.Payload), &notification); err != nil {
					r.Logger.Error("Failed to parse notification", map[string]interface{}{
						"error":   err,
						"payload": msg.Payload,
					})
					continue
				}

				// Send notification to GraphQL subscription
				select {
				case notificationChan <- &notification:
				case <-ctx.Done():
					return
				}
			}
		}
	}()

	r.Logger.Info("User subscribed to notifications", map[string]interface{}{
		"user_id": userID,
	})
	return notificationChan, nil
}

// SystemAnnouncements is the resolver for the systemAnnouncements field.
func (r *subscriptionResolver) SystemAnnouncements(ctx context.Context) (<-chan *model.SystemAnnouncement, error) {
	// Check if user has admin permission
	userClaims := ctx.Value("user_claims")
	if userClaims == nil {
		return nil, fmt.Errorf("user not authenticated")
	}

	// TODO: Implement proper RBAC check for admin permission
	r.Logger.Info("System announcements subscription", map[string]interface{}{
		"user_claims": userClaims,
	})

	// Create channel for announcements
	announcementChan := make(chan *model.SystemAnnouncement, 10)

	// Subscribe to Redis Pub/Sub channel for system announcements
	channelName := "system:announcements"
	pubsub, err := r.RedisClient.Subscribe(ctx, channelName)
	if err != nil {
		return nil, fmt.Errorf("failed to subscribe to system announcements: %w", err)
	}

	go func() {
		defer close(announcementChan)
		defer pubsub.Close()

		for {
			select {
			case <-ctx.Done():
				r.Logger.Info("System announcement subscription cancelled", map[string]interface{}{})
				return
			case msg := <-pubsub.Channel():
				if msg == nil {
					continue
				}

				// Parse the announcement message
				var announcement model.SystemAnnouncement
				if err := json.Unmarshal([]byte(msg.Payload), &announcement); err != nil {
					r.Logger.Error("Failed to parse system announcement", map[string]interface{}{
						"error":   err,
						"payload": msg.Payload,
					})
					continue
				}

				// Send announcement to GraphQL subscription
				select {
				case announcementChan <- &announcement:
				case <-ctx.Done():
					return
				}
			}
		}
	}()

	r.Logger.Info("User subscribed to system announcements", map[string]interface{}{})
	return announcementChan, nil
}

// Subscription returns generated.SubscriptionResolver implementation.
func (r *Resolver) Subscription() generated.SubscriptionResolver { return &subscriptionResolver{r} }

type subscriptionResolver struct{ *Resolver }
