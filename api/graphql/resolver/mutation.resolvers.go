package resolver

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.78

import (
	"context"
	"erp-api-gateway/api/graphql/generated"
	"erp-api-gateway/api/graphql/model"
	"erp-api-gateway/internal/interfaces"
	authpb "erp-api-gateway/proto/gen/auth"
	"fmt"
	"time"
)

// Authenticate is the resolver for the login field.
func (r *mutationResolver) Authenticate(ctx context.Context, input model.LoginInput) (*model.AuthResponse, error) {
	// Call auth service via gRPC
	authClient, err := r.GRPCClient.AuthService(ctx)
	if err != nil {
		r.Logger.Error("Failed to get auth client", map[string]interface{}{
			"error": err,
			"email": input.Email,
		})
		return nil, fmt.Errorf("authentication service unavailable")
	}

	resp, err := authClient.Authenticate(ctx, &authpb.AuthenticateRequest{
		Email:      input.Email,
		Password:   input.Password,
		RememberMe: input.RememberMe != nil && *input.RememberMe,
	})

	if err != nil {
		r.Logger.Error("Login gRPC call failed", map[string]interface{}{
			"error": err,
			"email": input.Email,
		})
		return nil, fmt.Errorf("authentication service unavailable")
	}

	if !resp.Success {
		r.Logger.Info("Login failed", map[string]interface{}{
			"email": input.Email,
			"error": resp.Error,
		})
		return nil, fmt.Errorf("login failed: %s", resp.Error)
	}

	// Publish login event to Kafka
	go func() {
		event := interfaces.Event{
			Type:   "user.logged_in",
			UserID: resp.User.Id,
			Data: map[string]interface{}{
				"email":      resp.User.Email,
				"login_time": time.Now(),
			},
			Timestamp: time.Now(),
		}
		if err := r.KafkaProducer.PublishUserEvent(context.Background(), resp.User.Id, event); err != nil {
			r.Logger.Error("Failed to publish login event", map[string]interface{}{
				"error":   err,
				"user_id": resp.User.Id,
			})
		}
	}()

	return &model.AuthResponse{
		User:         convertProtoUserToGraphQL(resp.User),
		AccessToken:  resp.Tokens.AccessToken,
		RefreshToken: resp.Tokens.RefreshToken,
		ExpiresIn:    int(resp.Tokens.ExpiresAt.Seconds - time.Now().Unix()),
	}, nil
}

// CreateUser is the resolver for the register field.
func (r *mutationResolver) CreateUser(ctx context.Context, input model.RegisterInput) (*model.AuthResponse, error) {
	// Call auth service via gRPC
	authClient, err := r.GRPCClient.AuthService(ctx)
	if err != nil {
		r.Logger.Error("Failed to get auth client", map[string]interface{}{
			"error": err,
			"email": input.Email,
		})
		return nil, fmt.Errorf("authentication service unavailable")
	}

	resp, err := authClient.CreateUser(ctx, &authpb.CreateUserRequest{
		FirstName: input.FirstName,
		LastName:  input.LastName,
		Email:     input.Email,
		Password:  input.Password,
	})

	if err != nil {
		r.Logger.Error("Register gRPC call failed", map[string]interface{}{
			"error": err,
			"email": input.Email,
		})
		return nil, fmt.Errorf("authentication service unavailable")
	}

	if !resp.Success {
		r.Logger.Info("Registration failed", map[string]interface{}{
			"email": input.Email,
			"error": resp.Error,
		})
		return nil, fmt.Errorf("registration failed: %s", resp.Error)
	}

	// Publish registration event to Kafka
	go func() {
		event := interfaces.Event{
			Type:   "user.registered",
			UserID: resp.User.Id,
			Data: map[string]interface{}{
				"email":             resp.User.Email,
				"first_name":        resp.User.FirstName,
				"last_name":         resp.User.LastName,
				"registration_time": time.Now(),
			},
			Timestamp: time.Now(),
		}
		if err := r.KafkaProducer.PublishUserEvent(context.Background(), resp.User.Id, event); err != nil {
			r.Logger.Error("Failed to publish registration event", map[string]interface{}{
				"error":   err,
				"user_id": resp.User.Id,
			})
		}
	}()

	// Note: CreateUser doesn't return tokens, so we need to authenticate after registration
	// For now, return a response without tokens - the client should call authenticate separately
	return &model.AuthResponse{
		User:         convertProtoUserToGraphQL(resp.User),
		AccessToken:  "", // CreateUser doesn't provide tokens
		RefreshToken: "", // CreateUser doesn't provide tokens
		ExpiresIn:    0,  // CreateUser doesn't provide tokens
	}, nil
}

// Logout is the resolver for the logout field.
func (r *mutationResolver) RevokeToken(ctx context.Context) (*model.MutationResponse, error) {
	// Get user ID from context
	userID, exists := ctx.Value("user_id").(string)
	if !exists {
		return &model.MutationResponse{
			Success: false,
			Message: "User not authenticated",
		}, nil
	}

	// Publish logout event to Kafka
	go func() {
		event := interfaces.Event{
			Type:   "user.logged_out",
			UserID: userID,
			Data: map[string]interface{}{
				"logout_time": time.Now(),
			},
			Timestamp: time.Now(),
		}
		if err := r.KafkaProducer.PublishUserEvent(context.Background(), userID, event); err != nil {
			r.Logger.Error("Failed to publish logout event", map[string]interface{}{
				"error":   err,
				"user_id": userID,
			})
		}
	}()

	r.Logger.Info("User logged out", map[string]interface{}{
		"user_id": userID,
	})

	return &model.MutationResponse{
		Success: true,
		Message: "Successfully logged out",
	}, nil
}

// RefreshToken is the resolver for the refreshToken field.
func (r *mutationResolver) RefreshToken(ctx context.Context, refreshToken string) (*model.AuthResponse, error) {
	// Call auth service via gRPC
	authClient, err := r.GRPCClient.AuthService(ctx)
	if err != nil {
		r.Logger.Error("Failed to get auth client", map[string]interface{}{
			"error": err,
		})
		return nil, fmt.Errorf("authentication service unavailable")
	}

	resp, err := authClient.RefreshToken(ctx, &authpb.RefreshTokenRequest{
		RefreshToken: refreshToken,
	})

	if err != nil {
		r.Logger.Error("RefreshToken gRPC call failed", map[string]interface{}{
			"error": err,
		})
		return nil, fmt.Errorf("authentication service unavailable")
	}

	if resp.Error != "" {
		r.Logger.Info("Token refresh failed", map[string]interface{}{
			"error": resp.Error,
		})
		return nil, fmt.Errorf("token refresh failed: %s", resp.Error)
	}

	// For refresh token, we need to get user info separately
	// since the refresh response only contains tokens
	return &model.AuthResponse{
		User:         &model.User{}, // Would need to fetch user info separately
		AccessToken:  resp.AccessToken,
		RefreshToken: resp.RefreshToken,
		ExpiresIn:    int(resp.ExpiresIn),
	}, nil
}

// Mutation returns generated.MutationResolver implementation.
func (r *Resolver) Mutation() generated.MutationResolver { return &mutationResolver{r} }

type mutationResolver struct{ *Resolver }
