package resolver

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.78

import (
	"context"
	"erp-api-gateway/api/graphql/generated"
	"erp-api-gateway/api/graphql/model"
	"erp-api-gateway/internal/interfaces"
	authpb "erp-api-gateway/proto"
	"fmt"
	"time"
)

// Authenticate is the resolver for the login field.
func (r *mutationResolver) Authenticate(ctx context.Context, input model.LoginInput) (*model.AuthResponse, error) {
	// Call auth service via gRPC
	authClient, err := r.GRPCClient.AuthService(ctx)
	if err != nil {
		r.Logger.Error("Failed to get auth client", map[string]interface{}{
			"error": err,
			"email": input.Email,
		})
		return nil, fmt.Errorf("authentication service unavailable")
	}

	resp, err := authClient.Authenticate(ctx, &authpb.AuthenticateRequest{
		Email:      input.Email,
		Password:   input.Password,
		RememberMe: input.RememberMe != nil && *input.RememberMe,
	})

	if err != nil {
		r.Logger.Error("Login gRPC call failed", map[string]interface{}{
			"error": err,
			"email": input.Email,
		})
		return nil, fmt.Errorf("authentication service unavailable")
	}

	if !resp.Success {
		r.Logger.Info("Login failed", map[string]interface{}{
			"email": input.Email,
			"error": resp.Error,
		})
		return nil, fmt.Errorf("login failed: %s", resp.Error)
	}

	// Publish login event to Kafka
	go func() {
		event := interfaces.Event{
			Type:   "user.logged_in",
			UserID: resp.User.Id,
			Data: map[string]interface{}{
				"email":      resp.User.Email,
				"login_time": time.Now(),
			},
			Timestamp: time.Now(),
		}
		if err := r.KafkaProducer.PublishUserEvent(context.Background(), resp.User.Id, event); err != nil {
			r.Logger.Error("Failed to publish login event", map[string]interface{}{
				"error":   err,
				"user_id": resp.User.Id,
			})
		}
	}()

	return &model.AuthResponse{
		User:         convertProtoUserToGraphQL(resp.User),
		AccessToken:  resp.Tokens.AccessToken,
		RefreshToken: resp.Tokens.RefreshToken,
		ExpiresIn:    int(resp.Tokens.ExpiresAt.Seconds - time.Now().Unix()),
	}, nil
}

// CreateUser is the resolver for the register field.
func (r *mutationResolver) CreateUser(ctx context.Context, input model.RegisterInput) (*model.AuthResponse, error) {
	// Call auth service via gRPC
	authClient, err := r.GRPCClient.AuthService(ctx)
	if err != nil {
		r.Logger.Error("Failed to get auth client", map[string]interface{}{
			"error": err,
			"email": input.Email,
		})
		return nil, fmt.Errorf("authentication service unavailable")
	}

	resp, err := authClient.CreateUser(ctx, &authpb.CreateUserRequest{
		FirstName: input.FirstName,
		LastName:  input.LastName,
		Email:     input.Email,
		Password:  input.Password,
	})

	if err != nil {
		r.Logger.Error("Register gRPC call failed", map[string]interface{}{
			"error": err,
			"email": input.Email,
		})
		return nil, fmt.Errorf("authentication service unavailable")
	}

	if !resp.Success {
		r.Logger.Info("Registration failed", map[string]interface{}{
			"email": input.Email,
			"error": resp.Error,
		})
		return nil, fmt.Errorf("registration failed: %s", resp.Error)
	}

	// Publish registration event to Kafka
	go func() {
		event := interfaces.Event{
			Type:   "user.registered",
			UserID: resp.User.Id,
			Data: map[string]interface{}{
				"email":             resp.User.Email,
				"first_name":        resp.User.FirstName,
				"last_name":         resp.User.LastName,
				"registration_time": time.Now(),
			},
			Timestamp: time.Now(),
		}
		if err := r.KafkaProducer.PublishUserEvent(context.Background(), resp.User.Id, event); err != nil {
			r.Logger.Error("Failed to publish registration event", map[string]interface{}{
				"error":   err,
				"user_id": resp.User.Id,
			})
		}
	}()

	// Note: CreateUser doesn't return tokens, so we need to authenticate after registration
	// For now, return a response without tokens - the client should call authenticate separately
	return &model.AuthResponse{
		User:         convertProtoUserToGraphQL(resp.User),
		AccessToken:  "", // CreateUser doesn't provide tokens
		RefreshToken: "", // CreateUser doesn't provide tokens
		ExpiresIn:    0,  // CreateUser doesn't provide tokens
	}, nil
}

// Logout is the resolver for the logout field.
func (r *mutationResolver) RevokeToken(ctx context.Context) (*model.MutationResponse, error) {
	// Get user ID from context
	userID, exists := ctx.Value("user_id").(string)
	if !exists {
		return &model.MutationResponse{
			Success: false,
			Message: "User not authenticated",
		}, nil
	}

	// Publish logout event to Kafka
	go func() {
		event := interfaces.Event{
			Type:   "user.logged_out",
			UserID: userID,
			Data: map[string]interface{}{
				"logout_time": time.Now(),
			},
			Timestamp: time.Now(),
		}
		if err := r.KafkaProducer.PublishUserEvent(context.Background(), userID, event); err != nil {
			r.Logger.Error("Failed to publish logout event", map[string]interface{}{
				"error":   err,
				"user_id": userID,
			})
		}
	}()

	r.Logger.Info("User logged out", map[string]interface{}{
		"user_id": userID,
	})

	return &model.MutationResponse{
		Success: true,
		Message: "Successfully logged out",
	}, nil
}

// RefreshToken is the resolver for the refreshToken field.
func (r *mutationResolver) RefreshToken(ctx context.Context, refreshToken string) (*model.AuthResponse, error) {
	// Call auth service via gRPC
	authClient, err := r.GRPCClient.AuthService(ctx)
	if err != nil {
		r.Logger.Error("Failed to get auth client", map[string]interface{}{
			"error": err,
		})
		return nil, fmt.Errorf("authentication service unavailable")
	}

	resp, err := authClient.RefreshToken(ctx, &authpb.RefreshTokenRequest{
		RefreshToken: refreshToken,
	})

	if err != nil {
		r.Logger.Error("RefreshToken gRPC call failed", map[string]interface{}{
			"error": err,
		})
		return nil, fmt.Errorf("authentication service unavailable")
	}

	if resp.Error != "" {
		r.Logger.Info("Token refresh failed", map[string]interface{}{
			"error": resp.Error,
		})
		return nil, fmt.Errorf("token refresh failed: %s", resp.Error)
	}

	// For refresh token, we need to get user info separately
	// since the refresh response only contains tokens
	return &model.AuthResponse{
		User:         &model.User{}, // Would need to fetch user info separately
		AccessToken:  resp.AccessToken,
		RefreshToken: resp.RefreshToken,
		ExpiresIn:    int(resp.ExpiresIn),
	}, nil
}

// CreateUserAdmin is the resolver for the createUserAdmin field.
func (r *mutationResolver) CreateUserAdmin(ctx context.Context, input model.CreateUserInput) (*model.UserMutationResponse, error) {
	// Check if user has admin permission
	userClaims := ctx.Value("user_claims")
	if userClaims == nil {
		return &model.UserMutationResponse{
			Success: false,
			Message: "User not authenticated",
			Errors:  []*model.FieldError{{Field: "auth", Message: "Authentication required"}},
		}, nil
	}

	// Get organization ID from context
	orgID, exists := ctx.Value("organization_id").(string)
	if !exists {
		return &model.UserMutationResponse{
			Success: false,
			Message: "Organization context not found",
			Errors:  []*model.FieldError{{Field: "organization", Message: "Organization context required"}},
		}, nil
	}

	// Call auth service via gRPC
	authClient, err := r.GRPCClient.AuthService(ctx)
	if err != nil {
		r.Logger.Error("Failed to get auth client", map[string]interface{}{
			"error": err,
		})
		return &model.UserMutationResponse{
			Success: false,
			Message: "Authentication service unavailable",
			Errors:  []*model.FieldError{{Field: "service", Message: "Service unavailable"}},
		}, nil
	}

	resp, err := authClient.CreateUser(ctx, &authpb.CreateUserRequest{
		OrganizationId: orgID,
		Email:          input.Email,
		Password:       input.Password,
		FirstName:      input.FirstName,
		LastName:       input.LastName,
		IsActive:       input.IsActive != nil && *input.IsActive,
		IsVerified:     input.IsVerified != nil && *input.IsVerified,
		RoleIds:        input.RoleIds,
	})

	if err != nil {
		r.Logger.Error("CreateUser gRPC call failed", map[string]interface{}{
			"error": err,
			"email": input.Email,
		})
		return &model.UserMutationResponse{
			Success: false,
			Message: "Failed to create user",
			Errors:  []*model.FieldError{{Field: "general", Message: "Service error occurred"}},
		}, nil
	}

	if !resp.Success {
		return &model.UserMutationResponse{
			Success: false,
			Message: "Failed to create user",
			Errors:  []*model.FieldError{{Field: "general", Message: resp.Error}},
		}, nil
	}

	return &model.UserMutationResponse{
		Success: true,
		Message: "User created successfully",
		User:    convertProtoUserToGraphQL(resp.User),
	}, nil
}

// UpdateUser is the resolver for the updateUser field.
func (r *mutationResolver) UpdateUser(ctx context.Context, id string, input model.UpdateUserInput) (*model.UserMutationResponse, error) {
	// Check if user has admin permission
	userClaims := ctx.Value("user_claims")
	if userClaims == nil {
		return &model.UserMutationResponse{
			Success: false,
			Message: "User not authenticated",
			Errors:  []*model.FieldError{{Field: "auth", Message: "Authentication required"}},
		}, nil
	}

	// Call auth service via gRPC
	authClient, err := r.GRPCClient.AuthService(ctx)
	if err != nil {
		r.Logger.Error("Failed to get auth client", map[string]interface{}{
			"error": err,
		})
		return &model.UserMutationResponse{
			Success: false,
			Message: "Authentication service unavailable",
			Errors:  []*model.FieldError{{Field: "service", Message: "Service unavailable"}},
		}, nil
	}

	resp, err := authClient.UpdateUser(ctx, &authpb.UpdateUserRequest{
		UserId: id,
		Email: func() string {
			if input.Email != nil {
				return *input.Email
			}
			return ""
		}(),
		FirstName: func() string {
			if input.FirstName != nil {
				return *input.FirstName
			}
			return ""
		}(),
		LastName: func() string {
			if input.LastName != nil {
				return *input.LastName
			}
			return ""
		}(),
		IsActive:   input.IsActive != nil && *input.IsActive,
		IsVerified: input.IsVerified != nil && *input.IsVerified,
		RoleIds:    input.RoleIds,
	})

	if err != nil {
		r.Logger.Error("UpdateUser gRPC call failed", map[string]interface{}{
			"error":   err,
			"user_id": id,
		})
		return &model.UserMutationResponse{
			Success: false,
			Message: "Failed to update user",
			Errors:  []*model.FieldError{{Field: "general", Message: "Service error occurred"}},
		}, nil
	}

	if !resp.Success {
		return &model.UserMutationResponse{
			Success: false,
			Message: "Failed to update user",
			Errors:  []*model.FieldError{{Field: "general", Message: resp.Error}},
		}, nil
	}

	return &model.UserMutationResponse{
		Success: true,
		Message: "User updated successfully",
		User:    convertProtoUserToGraphQL(resp.User),
	}, nil
}

// DeleteUser is the resolver for the deleteUser field.
func (r *mutationResolver) DeleteUser(ctx context.Context, id string) (*model.MutationResponse, error) {
	// Check if user has admin permission
	userClaims := ctx.Value("user_claims")
	if userClaims == nil {
		return &model.MutationResponse{
			Success: false,
			Message: "User not authenticated",
			Errors:  []*model.FieldError{{Field: "auth", Message: "Authentication required"}},
		}, nil
	}

	// Call auth service via gRPC
	authClient, err := r.GRPCClient.AuthService(ctx)
	if err != nil {
		r.Logger.Error("Failed to get auth client", map[string]interface{}{
			"error": err,
		})
		return &model.MutationResponse{
			Success: false,
			Message: "Authentication service unavailable",
			Errors:  []*model.FieldError{{Field: "service", Message: "Service unavailable"}},
		}, nil
	}

	resp, err := authClient.DeleteUser(ctx, &authpb.DeleteUserRequest{
		UserId: id,
	})

	if err != nil {
		r.Logger.Error("DeleteUser gRPC call failed", map[string]interface{}{
			"error":   err,
			"user_id": id,
		})
		return &model.MutationResponse{
			Success: false,
			Message: "Failed to delete user",
			Errors:  []*model.FieldError{{Field: "general", Message: "Service error occurred"}},
		}, nil
	}

	if !resp.Success {
		return &model.MutationResponse{
			Success: false,
			Message: "Failed to delete user",
			Errors:  []*model.FieldError{{Field: "general", Message: resp.Error}},
		}, nil
	}

	return &model.MutationResponse{
		Success: true,
		Message: "User deleted successfully",
	}, nil
}

// ActivateUser is the resolver for the activateUser field.
func (r *mutationResolver) ActivateUser(ctx context.Context, id string) (*model.UserMutationResponse, error) {
	// Check if user has admin permission
	userClaims := ctx.Value("user_claims")
	if userClaims == nil {
		return &model.UserMutationResponse{
			Success: false,
			Message: "User not authenticated",
			Errors:  []*model.FieldError{{Field: "auth", Message: "Authentication required"}},
		}, nil
	}

	// Call auth service via gRPC
	authClient, err := r.GRPCClient.AuthService(ctx)
	if err != nil {
		r.Logger.Error("Failed to get auth client", map[string]interface{}{
			"error": err,
		})
		return &model.UserMutationResponse{
			Success: false,
			Message: "Authentication service unavailable",
			Errors:  []*model.FieldError{{Field: "service", Message: "Service unavailable"}},
		}, nil
	}

	resp, err := authClient.ActivateUser(ctx, &authpb.ActivateUserRequest{
		UserId: id,
	})

	if err != nil {
		r.Logger.Error("ActivateUser gRPC call failed", map[string]interface{}{
			"error":   err,
			"user_id": id,
		})
		return &model.UserMutationResponse{
			Success: false,
			Message: "Failed to activate user",
			Errors:  []*model.FieldError{{Field: "general", Message: "Service error occurred"}},
		}, nil
	}

	if !resp.Success {
		return &model.UserMutationResponse{
			Success: false,
			Message: "Failed to activate user",
			Errors:  []*model.FieldError{{Field: "general", Message: resp.Error}},
		}, nil
	}

	return &model.UserMutationResponse{
		Success: true,
		Message: "User activated successfully",
		User:    convertProtoUserToGraphQL(resp.User),
	}, nil
}

// DeactivateUser is the resolver for the deactivateUser field.
func (r *mutationResolver) DeactivateUser(ctx context.Context, id string) (*model.UserMutationResponse, error) {
	// Check if user has admin permission
	userClaims := ctx.Value("user_claims")
	if userClaims == nil {
		return &model.UserMutationResponse{
			Success: false,
			Message: "User not authenticated",
			Errors:  []*model.FieldError{{Field: "auth", Message: "Authentication required"}},
		}, nil
	}

	// Call auth service via gRPC
	authClient, err := r.GRPCClient.AuthService(ctx)
	if err != nil {
		r.Logger.Error("Failed to get auth client", map[string]interface{}{
			"error": err,
		})
		return &model.UserMutationResponse{
			Success: false,
			Message: "Authentication service unavailable",
			Errors:  []*model.FieldError{{Field: "service", Message: "Service unavailable"}},
		}, nil
	}

	resp, err := authClient.DeactivateUser(ctx, &authpb.DeactivateUserRequest{
		UserId: id,
	})

	if err != nil {
		r.Logger.Error("DeactivateUser gRPC call failed", map[string]interface{}{
			"error":   err,
			"user_id": id,
		})
		return &model.UserMutationResponse{
			Success: false,
			Message: "Failed to deactivate user",
			Errors:  []*model.FieldError{{Field: "general", Message: "Service error occurred"}},
		}, nil
	}

	if !resp.Success {
		return &model.UserMutationResponse{
			Success: false,
			Message: "Failed to deactivate user",
			Errors:  []*model.FieldError{{Field: "general", Message: resp.Error}},
		}, nil
	}

	return &model.UserMutationResponse{
		Success: true,
		Message: "User deactivated successfully",
		User:    convertProtoUserToGraphQL(resp.User),
	}, nil
}

// VerifyUser is the resolver for the verifyUser field.
func (r *mutationResolver) VerifyUser(ctx context.Context, id string) (*model.UserMutationResponse, error) {
	// Check if user has admin permission
	userClaims := ctx.Value("user_claims")
	if userClaims == nil {
		return &model.UserMutationResponse{
			Success: false,
			Message: "User not authenticated",
			Errors:  []*model.FieldError{{Field: "auth", Message: "Authentication required"}},
		}, nil
	}

	// Call auth service via gRPC
	authClient, err := r.GRPCClient.AuthService(ctx)
	if err != nil {
		r.Logger.Error("Failed to get auth client", map[string]interface{}{
			"error": err,
		})
		return &model.UserMutationResponse{
			Success: false,
			Message: "Authentication service unavailable",
			Errors:  []*model.FieldError{{Field: "service", Message: "Service unavailable"}},
		}, nil
	}

	resp, err := authClient.VerifyUser(ctx, &authpb.VerifyUserRequest{
		UserId: id,
	})

	if err != nil {
		r.Logger.Error("VerifyUser gRPC call failed", map[string]interface{}{
			"error":   err,
			"user_id": id,
		})
		return &model.UserMutationResponse{
			Success: false,
			Message: "Failed to verify user",
			Errors:  []*model.FieldError{{Field: "general", Message: "Service error occurred"}},
		}, nil
	}

	if !resp.Success {
		return &model.UserMutationResponse{
			Success: false,
			Message: "Failed to verify user",
			Errors:  []*model.FieldError{{Field: "general", Message: resp.Error}},
		}, nil
	}

	return &model.UserMutationResponse{
		Success: true,
		Message: "User verified successfully",
		User:    convertProtoUserToGraphQL(resp.User),
	}, nil
}

// ResetUserPassword is the resolver for the resetUserPassword field.
func (r *mutationResolver) ResetUserPassword(ctx context.Context, id string, newPassword string) (*model.MutationResponse, error) {
	panic(fmt.Errorf("not implemented: ResetUserPassword - resetUserPassword"))
}

// CreateRole is the resolver for the createRole field.
func (r *mutationResolver) CreateRole(ctx context.Context, input model.CreateRoleInput) (*model.RoleMutationResponse, error) {
	panic(fmt.Errorf("not implemented: CreateRole - createRole"))
}

// UpdateRole is the resolver for the updateRole field.
func (r *mutationResolver) UpdateRole(ctx context.Context, id string, input model.UpdateRoleInput) (*model.RoleMutationResponse, error) {
	panic(fmt.Errorf("not implemented: UpdateRole - updateRole"))
}

// DeleteRole is the resolver for the deleteRole field.
func (r *mutationResolver) DeleteRole(ctx context.Context, id string) (*model.MutationResponse, error) {
	panic(fmt.Errorf("not implemented: DeleteRole - deleteRole"))
}

// AssignUserRole is the resolver for the assignUserRole field.
func (r *mutationResolver) AssignUserRole(ctx context.Context, userID string, roleID string) (*model.MutationResponse, error) {
	// Require authentication
	if _, exists := ctx.Value("user_id").(string); !exists {
		return &model.MutationResponse{Success: false, Message: "User not authenticated"}, nil
	}

	// Call auth service via gRPC
	authClient, err := r.GRPCClient.AuthService(ctx)
	if err != nil {
		r.Logger.Error("AssignUserRole: failed to get auth client", map[string]interface{}{"error": err})
		return &model.MutationResponse{Success: false, Message: "Service unavailable"}, nil
	}

	resp, err := authClient.AssignUserRole(ctx, &authpb.AssignUserRoleRequest{UserId: userID, RoleId: roleID})
	if err != nil {
		r.Logger.Error("AssignUserRole: gRPC call failed", map[string]interface{}{"error": err})
		return &model.MutationResponse{Success: false, Message: "Failed to assign role"}, nil
	}

	if !resp.Success {
		return &model.MutationResponse{Success: false, Message: resp.Error}, nil
	}

	return &model.MutationResponse{Success: true, Message: "Role assigned"}, nil
}

// RevokeUserRole is the resolver for the revokeUserRole field.
func (r *mutationResolver) RevokeUserRole(ctx context.Context, userID string, roleID string) (*model.MutationResponse, error) {
	panic(fmt.Errorf("not implemented: RevokeUserRole - revokeUserRole"))
}

// AssignPermissions is the resolver for the assignPermissions field.
func (r *mutationResolver) AssignPermissions(ctx context.Context, roleID string, permissionIds []string) (*model.MutationResponse, error) {
	panic(fmt.Errorf("not implemented: AssignPermissions - assignPermissions"))
}

// BulkCreateUsers is the resolver for the bulkCreateUsers field.
func (r *mutationResolver) BulkCreateUsers(ctx context.Context, input model.BulkCreateUsersInput) (*model.BulkUserMutationResponse, error) {
	panic(fmt.Errorf("not implemented: BulkCreateUsers - bulkCreateUsers"))
}

// BulkUpdateUsers is the resolver for the bulkUpdateUsers field.
func (r *mutationResolver) BulkUpdateUsers(ctx context.Context, input model.BulkUpdateUsersInput) (*model.BulkUserMutationResponse, error) {
	panic(fmt.Errorf("not implemented: BulkUpdateUsers - bulkUpdateUsers"))
}

// BulkDeleteUsers is the resolver for the bulkDeleteUsers field.
func (r *mutationResolver) BulkDeleteUsers(ctx context.Context, userIds []string) (*model.BulkDeleteMutationResponse, error) {
	panic(fmt.Errorf("not implemented: BulkDeleteUsers - bulkDeleteUsers"))
}

// CreateOrganization is the resolver for the createOrganization field.
func (r *mutationResolver) CreateOrganization(ctx context.Context, input model.CreateOrganizationInput) (*model.OrganizationMutationResponse, error) {
	panic(fmt.Errorf("not implemented: CreateOrganization - createOrganization"))
}

// UpdateOrganization is the resolver for the updateOrganization field.
func (r *mutationResolver) UpdateOrganization(ctx context.Context, id string, input model.UpdateOrganizationInput) (*model.OrganizationMutationResponse, error) {
	panic(fmt.Errorf("not implemented: UpdateOrganization - updateOrganization"))
}

// DeleteOrganization is the resolver for the deleteOrganization field.
func (r *mutationResolver) DeleteOrganization(ctx context.Context, id string) (*model.MutationResponse, error) {
	panic(fmt.Errorf("not implemented: DeleteOrganization - deleteOrganization"))
}

// ActivateOrganization is the resolver for the activateOrganization field.
func (r *mutationResolver) ActivateOrganization(ctx context.Context, id string) (*model.OrganizationMutationResponse, error) {
	panic(fmt.Errorf("not implemented: ActivateOrganization - activateOrganization"))
}

// DeactivateOrganization is the resolver for the deactivateOrganization field.
func (r *mutationResolver) DeactivateOrganization(ctx context.Context, id string) (*model.OrganizationMutationResponse, error) {
	panic(fmt.Errorf("not implemented: DeactivateOrganization - deactivateOrganization"))
}

// Mutation returns generated.MutationResolver implementation.
func (r *Resolver) Mutation() generated.MutationResolver { return &mutationResolver{r} }

type mutationResolver struct{ *Resolver }
