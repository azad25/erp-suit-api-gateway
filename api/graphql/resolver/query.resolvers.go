package resolver

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.78

import (
	"context"
	"erp-api-gateway/api/graphql/generated"
	"erp-api-gateway/api/graphql/model"
	authpb "erp-api-gateway/proto/gen/auth"
	"fmt"
)

// Me is the resolver for the me field.
func (r *queryResolver) Me(ctx context.Context) (*model.User, error) {
	// Get user ID from context (set by auth middleware)
	userID, exists := ctx.Value("user_id").(string)
	if !exists {
		return nil, fmt.Errorf("user not authenticated")
	}

	// Use DataLoader to get user
	if dl := r.DataLoader; dl != nil {
		return dl.GetUser(ctx, userID)
	}

	// Fallback to direct gRPC call
	r.Logger.Info("Getting auth client for user lookup", map[string]interface{}{
		"user_id": userID,
	})
	
	authClient, err := r.GRPCClient.AuthService(ctx)
	if err != nil {
		r.Logger.Error("Failed to get auth client", map[string]interface{}{
			"error":   err,
			"user_id": userID,
		})
		return nil, fmt.Errorf("authentication service unavailable")
	}

	r.Logger.Info("Making gRPC GetUser call", map[string]interface{}{
		"user_id": userID,
	})

	resp, err := authClient.GetUser(ctx, &authpb.GetUserRequest{
		UserId: userID,
	})

	if err != nil {
		r.Logger.Error("Failed to get current user", map[string]interface{}{
			"error":   err,
			"user_id": userID,
			"error_type": fmt.Sprintf("%T", err),
		})
		return nil, fmt.Errorf("failed to get user information")
	}

	r.Logger.Info("gRPC GetUser call completed", map[string]interface{}{
		"user_id": userID,
	})

	// Debug logging for response
	r.Logger.Info("GetUser gRPC response received", map[string]interface{}{
		"user_id":    userID,
		"error":      resp.Error,
		"user_nil":   resp.User == nil,
		"has_error":  resp.Error != "",
		"error_len":  len(resp.Error),
	})

	// Check if we have a user even if there's an error field set
	if resp.User == nil {
		r.Logger.Error("GetUser response user is nil", map[string]interface{}{
			"user_id": userID,
			"error":   resp.Error,
		})
		return nil, fmt.Errorf("user not found: %s", userID)
	}

	// Only return error if we don't have a user AND there's an actual error
	if resp.Error != "" && resp.User == nil {
		r.Logger.Error("GetUser response contains error", map[string]interface{}{
			"user_id": userID,
			"error":   resp.Error,
		})
		return nil, fmt.Errorf("user not found: %s", userID)
	}

	if resp.User == nil {
		r.Logger.Error("GetUser response user is nil", map[string]interface{}{
			"user_id": userID,
		})
		return nil, fmt.Errorf("user not found")
	}

	r.Logger.Info("Converting user to GraphQL", map[string]interface{}{
		"user_id": userID,
		"email":   resp.User.Email,
	})

	return convertProtoUserToGraphQL(resp.User), nil
}

// User is the resolver for the user field.
func (r *queryResolver) User(ctx context.Context, id string) (*model.User, error) {
	// Check if user has admin permission
	userClaims := ctx.Value("user_claims")
	if userClaims == nil {
		return nil, fmt.Errorf("user not authenticated")
	}

	// TODO: Implement proper RBAC check for admin permission
	// For now, just check if user is authenticated

	// Use DataLoader to get user
	if dl := r.DataLoader; dl != nil {
		return dl.GetUser(ctx, id)
	}

	// Fallback to direct gRPC call
	authClient, err := r.GRPCClient.AuthService(ctx)
	if err != nil {
		r.Logger.Error("Failed to get auth client", map[string]interface{}{
			"error":   err,
			"user_id": id,
		})
		return nil, fmt.Errorf("authentication service unavailable")
	}

	resp, err := authClient.GetUser(ctx, &authpb.GetUserRequest{
		UserId: id,
	})

	if err != nil {
		r.Logger.Error("Failed to get user", map[string]interface{}{
			"error":   err,
			"user_id": id,
		})
		return nil, fmt.Errorf("failed to get user information")
	}

	if resp.Error != "" {
		return nil, fmt.Errorf("failed to get user: %s", resp.Error)
	}

	if resp.User == nil {
		return nil, fmt.Errorf("user not found")
	}

	return convertProtoUserToGraphQL(resp.User), nil
}

// Users is the resolver for the users field.
func (r *queryResolver) Users(ctx context.Context, limit *int, offset *int, search *string, sortBy *string, sortOrder *string) (*model.UserConnection, error) {
	// Check if user has admin permission
	userClaims := ctx.Value("user_claims")
	if userClaims == nil {
		return nil, fmt.Errorf("user not authenticated")
	}

	// Set defaults
	if limit == nil {
		defaultLimit := 10
		limit = &defaultLimit
	}
	if offset == nil {
		defaultOffset := 0
		offset = &defaultOffset
	}
	if sortBy == nil {
		defaultSortBy := "created_at"
		sortBy = &defaultSortBy
	}
	if sortOrder == nil {
		defaultSortOrder := "desc"
		sortOrder = &defaultSortOrder
	}

	// Get organization ID from context
	orgID, exists := ctx.Value("organization_id").(string)
	if !exists {
		return nil, fmt.Errorf("organization context not found")
	}

	// Call auth service via gRPC
	authClient, err := r.GRPCClient.AuthService(ctx)
	if err != nil {
		r.Logger.Error("Failed to get auth client", map[string]interface{}{
			"error": err,
		})
		return nil, fmt.Errorf("authentication service unavailable")
	}

	searchStr := ""
	if search != nil {
		searchStr = *search
	}

	resp, err := authClient.ListUsers(ctx, &authpb.ListUsersRequest{
		OrganizationId: orgID,
		Limit:          int32(*limit),
		Offset:         int32(*offset),
		Search:         searchStr,
		SortBy:         *sortBy,
		SortOrder:      *sortOrder,
	})

	if err != nil {
		r.Logger.Error("Failed to list users", map[string]interface{}{
			"error":  err,
			"org_id": orgID,
		})
		return nil, fmt.Errorf("failed to list users")
	}

	if !resp.Success {
		return nil, fmt.Errorf("failed to list users: %s", resp.Error)
	}

	// Convert to GraphQL format
	edges := make([]*model.UserEdge, len(resp.Users))
	for i, user := range resp.Users {
		edges[i] = &model.UserEdge{
			Node:   convertProtoUserToGraphQL(user),
			Cursor: fmt.Sprintf("%d", *offset+i+1),
		}
	}

	return &model.UserConnection{
		Edges:      edges,
		TotalCount: int(resp.TotalCount),
		PageInfo: &model.PageInfo{
			HasNextPage:     resp.HasNextPage,
			HasPreviousPage: *offset > 0,
			StartCursor:     getStartCursor(edges),
			EndCursor:       getEndCursor(edges),
		},
	}, nil
}

// UserStats is the resolver for the userStats field.
func (r *queryResolver) UserStats(ctx context.Context) (*model.UserStats, error) {
	// Check if user has admin permission
	userClaims := ctx.Value("user_claims")
	if userClaims == nil {
		return nil, fmt.Errorf("user not authenticated")
	}

	// Get organization ID from context
	orgID, exists := ctx.Value("organization_id").(string)
	if !exists {
		return nil, fmt.Errorf("organization context not found")
	}

	// Call auth service via gRPC
	authClient, err := r.GRPCClient.AuthService(ctx)
	if err != nil {
		r.Logger.Error("Failed to get auth client", map[string]interface{}{
			"error": err,
		})
		return nil, fmt.Errorf("authentication service unavailable")
	}

	resp, err := authClient.GetUserStats(ctx, &authpb.GetUserStatsRequest{
		OrganizationId: orgID,
	})

	if err != nil {
		r.Logger.Error("Failed to get user stats", map[string]interface{}{
			"error":  err,
			"org_id": orgID,
		})
		return nil, fmt.Errorf("failed to get user statistics")
	}

	if !resp.Success {
		return nil, fmt.Errorf("failed to get user stats: %s", resp.Error)
	}

	if resp.Stats == nil {
		return &model.UserStats{
			TotalUsers:      0,
			ActiveUsers:     0,
			InactiveUsers:   0,
			VerifiedUsers:   0,
			UnverifiedUsers: 0,
			RecentSignups:   0,
			RecentLogins:    0,
		}, nil
	}

	return &model.UserStats{
		TotalUsers:      int(resp.Stats.TotalUsers),
		ActiveUsers:     int(resp.Stats.ActiveUsers),
		InactiveUsers:   int(resp.Stats.InactiveUsers),
		VerifiedUsers:   int(resp.Stats.VerifiedUsers),
		UnverifiedUsers: int(resp.Stats.UnverifiedUsers),
		RecentSignups:   int(resp.Stats.RecentSignups),
		RecentLogins:    int(resp.Stats.RecentLogins),
	}, nil
}

// SecurityStats is the resolver for the securityStats field.
func (r *queryResolver) SecurityStats(ctx context.Context) (*model.SecurityStats, error) {
	// Check if user has admin permission
	userClaims := ctx.Value("user_claims")
	if userClaims == nil {
		r.Logger.Error("SecurityStats: user not authenticated", map[string]interface{}{})
		return nil, fmt.Errorf("user not authenticated")
	}

	// Get organization ID from context, fallback to user claims
	orgID, exists := ctx.Value("organization_id").(string)
	if !exists {
		// Try to get from user_id context and extract from JWT or database
		userID, userExists := ctx.Value("user_id").(string)
		if !userExists {
			r.Logger.Error("SecurityStats: no user context found", map[string]interface{}{})
			return nil, fmt.Errorf("user context not found")
		}
		
		// Get user info to find organization ID
		authClient, err := r.GRPCClient.AuthService(ctx)
		if err != nil {
			r.Logger.Error("SecurityStats: failed to get auth client for user lookup", map[string]interface{}{
				"error": err,
			})
			return nil, fmt.Errorf("authentication service unavailable")
		}
		
		userResp, err := authClient.GetUser(ctx, &authpb.GetUserRequest{
			UserId: userID,
		})
		
		if err != nil || userResp.Error != "" || userResp.User == nil {
			r.Logger.Error("SecurityStats: failed to get user for org lookup", map[string]interface{}{
				"error": err,
				"user_id": userID,
			})
			return nil, fmt.Errorf("failed to get user organization")
		}
		
		orgID = userResp.User.OrganizationId
		r.Logger.Info("SecurityStats: got org ID from user lookup", map[string]interface{}{
			"user_id": userID,
			"org_id": orgID,
		})
	} else {
		r.Logger.Info("SecurityStats: got org ID from context", map[string]interface{}{
			"org_id": orgID,
		})
	}

	// Call auth service via gRPC
	authClient, err := r.GRPCClient.AuthService(ctx)
	if err != nil {
		r.Logger.Error("Failed to get auth client", map[string]interface{}{
			"error": err,
		})
		return nil, fmt.Errorf("authentication service unavailable")
	}

	resp, err := authClient.GetSecurityStats(ctx, &authpb.GetSecurityStatsRequest{
		OrganizationId: orgID,
	})

	if err != nil {
		r.Logger.Error("Failed to get security stats", map[string]interface{}{
			"error":  err,
			"org_id": orgID,
		})
		return nil, fmt.Errorf("failed to get security statistics")
	}

	if !resp.Success {
		return nil, fmt.Errorf("failed to get security stats: %s", resp.Error)
	}

	if resp.Stats == nil {
		return &model.SecurityStats{
			FailedLoginsToday:   0,
			LockedAccounts:      0,
			SecurityAlerts:      0,
			TwoFactorEnabled:    0,
			PasswordResetsToday: 0,
		}, nil
	}

	return &model.SecurityStats{
		FailedLoginsToday:   int(resp.Stats.FailedLoginsToday),
		LockedAccounts:      int(resp.Stats.LockedAccounts),
		SecurityAlerts:      int(resp.Stats.SecurityAlerts),
		TwoFactorEnabled:    int(resp.Stats.TwoFactorEnabled),
		PasswordResetsToday: int(resp.Stats.PasswordResetsToday),
	}, nil
}

// UserActivity is the resolver for the userActivity field.
func (r *queryResolver) UserActivity(ctx context.Context, userID *string, limit *int, offset *int) (*model.UserActivityConnection, error) {
	// Check if user has admin permission
	userClaims := ctx.Value("user_claims")
	if userClaims == nil {
		return nil, fmt.Errorf("user not authenticated")
	}

	// Set defaults
	if limit == nil {
		defaultLimit := 10
		limit = &defaultLimit
	}
	if offset == nil {
		defaultOffset := 0
		offset = &defaultOffset
	}

	// Get organization ID from context
	orgID, exists := ctx.Value("organization_id").(string)
	if !exists {
		return nil, fmt.Errorf("organization context not found")
	}

	// Call auth service via gRPC
	authClient, err := r.GRPCClient.AuthService(ctx)
	if err != nil {
		r.Logger.Error("Failed to get auth client", map[string]interface{}{
			"error": err,
		})
		return nil, fmt.Errorf("authentication service unavailable")
	}

	userIDStr := ""
	if userID != nil {
		userIDStr = *userID
	}

	resp, err := authClient.GetUserActivity(ctx, &authpb.GetUserActivityRequest{
		UserId:         userIDStr,
		OrganizationId: orgID,
		Limit:          int32(*limit),
		Offset:         int32(*offset),
	})

	if err != nil {
		r.Logger.Error("Failed to get user activity", map[string]interface{}{
			"error":   err,
			"org_id":  orgID,
			"user_id": userID,
		})
		return nil, fmt.Errorf("failed to get user activity")
	}

	if !resp.Success {
		return nil, fmt.Errorf("failed to get user activity: %s", resp.Error)
	}

	// Convert to GraphQL format
	edges := make([]*model.UserActivityEdge, len(resp.Activities))
	for i, activity := range resp.Activities {
		edges[i] = &model.UserActivityEdge{
			Node: &model.UserActivity{
				ID:        activity.Id,
				UserID:    activity.UserId,
				Action:    activity.Action,
				Resource:  activity.Resource,
				Details:   &activity.Details,
				IPAddress: activity.IpAddress,
				UserAgent: &activity.UserAgent,
				CreatedAt: activity.CreatedAt.AsTime().Format("2006-01-02T15:04:05Z07:00"),
				User: convertActivityUser(activity.User),
			},
			Cursor: fmt.Sprintf("%d", *offset+i+1),
		}
	}

	return &model.UserActivityConnection{
		Edges:      edges,
		TotalCount: int(resp.TotalCount),
		PageInfo: &model.PageInfo{
			HasNextPage:     int32(*offset+*limit) < resp.TotalCount,
			HasPreviousPage: *offset > 0,
			StartCursor:     getStartCursorActivity(edges),
			EndCursor:       getEndCursorActivity(edges),
		},
	}, nil
}

// Roles is the resolver for the roles field.
func (r *queryResolver) Roles(ctx context.Context) ([]*model.Role, error) {
	// Check if user has admin permission
	userClaims := ctx.Value("user_claims")
	if userClaims == nil {
		return nil, fmt.Errorf("user not authenticated")
	}

	// Get organization ID from context
	orgID, exists := ctx.Value("organization_id").(string)
	if !exists {
		return nil, fmt.Errorf("organization context not found")
	}

	// Call auth service via gRPC
	authClient, err := r.GRPCClient.AuthService(ctx)
	if err != nil {
		r.Logger.Error("Failed to get auth client", map[string]interface{}{
			"error": err,
		})
		return nil, fmt.Errorf("authentication service unavailable")
	}

	resp, err := authClient.ListRoles(ctx, &authpb.ListRolesRequest{
		OrganizationId: orgID,
	})

	if err != nil {
		r.Logger.Error("Failed to list roles", map[string]interface{}{
			"error":  err,
			"org_id": orgID,
		})
		return nil, fmt.Errorf("failed to list roles")
	}

	if !resp.Success {
		return nil, fmt.Errorf("failed to list roles: %s", resp.Error)
	}

	// Convert to GraphQL format
	roles := make([]*model.Role, len(resp.Roles))
	for i, role := range resp.Roles {
		permissions := make([]*model.Permission, len(role.Permissions))
		for j, perm := range role.Permissions {
			permissions[j] = &model.Permission{
				ID:          perm.Id,
				Name:        perm.Name,
				Description: &perm.Description,
				Resource:    perm.Resource,
				Action:      perm.Action,
				Scope:       &perm.Scope,
				IsSystem:    perm.IsSystem,
				CreatedAt:   perm.CreatedAt.AsTime().Format("2006-01-02T15:04:05Z07:00"),
				UpdatedAt:   perm.UpdatedAt.AsTime().Format("2006-01-02T15:04:05Z07:00"),
			}
		}

		roles[i] = &model.Role{
			ID:             role.Id,
			OrganizationID: &role.OrganizationId,
			Name:           role.Name,
			Description:    &role.Description,
			IsSystem:       role.IsSystem,
			IsActive:       role.IsActive,
			Permissions:    permissions,
			CreatedAt:      role.CreatedAt.AsTime().Format("2006-01-02T15:04:05Z07:00"),
			UpdatedAt:      role.UpdatedAt.AsTime().Format("2006-01-02T15:04:05Z07:00"),
		}
	}

	return roles, nil
}

// Permissions is the resolver for the permissions field.
func (r *queryResolver) Permissions(ctx context.Context) ([]*model.Permission, error) {
	// Check if user has admin permission
	userClaims := ctx.Value("user_claims")
	if userClaims == nil {
		return nil, fmt.Errorf("user not authenticated")
	}

	// Call auth service via gRPC
	authClient, err := r.GRPCClient.AuthService(ctx)
	if err != nil {
		r.Logger.Error("Failed to get auth client", map[string]interface{}{
			"error": err,
		})
		return nil, fmt.Errorf("authentication service unavailable")
	}

	resp, err := authClient.ListPermissions(ctx, &authpb.ListPermissionsRequest{})

	if err != nil {
		r.Logger.Error("Failed to list permissions", map[string]interface{}{
			"error": err,
		})
		return nil, fmt.Errorf("failed to list permissions")
	}

	if !resp.Success {
		return nil, fmt.Errorf("failed to list permissions: %s", resp.Error)
	}

	// Convert to GraphQL format
	permissions := make([]*model.Permission, len(resp.Permissions))
	for i, perm := range resp.Permissions {
		permissions[i] = &model.Permission{
			ID:          perm.Id,
			Name:        perm.Name,
			Description: &perm.Description,
			Resource:    perm.Resource,
			Action:      perm.Action,
			Scope:       &perm.Scope,
			IsSystem:    perm.IsSystem,
			CreatedAt:   perm.CreatedAt.AsTime().Format("2006-01-02T15:04:05Z07:00"),
			UpdatedAt:   perm.UpdatedAt.AsTime().Format("2006-01-02T15:04:05Z07:00"),
		}
	}

	return permissions, nil
}

// Health is the resolver for the health field.
func (r *queryResolver) Health(ctx context.Context) (string, error) {
	return "OK", nil
}

// Helper functions for cursor management
func getStartCursor(edges []*model.UserEdge) *string {
	if len(edges) > 0 {
		return &edges[0].Cursor
	}
	return nil
}

func getEndCursor(edges []*model.UserEdge) *string {
	if len(edges) > 0 {
		return &edges[len(edges)-1].Cursor
	}
	return nil
}

func getStartCursorActivity(edges []*model.UserActivityEdge) *string {
	if len(edges) > 0 {
		return &edges[0].Cursor
	}
	return nil
}

func getEndCursorActivity(edges []*model.UserActivityEdge) *string {
	if len(edges) > 0 {
		return &edges[len(edges)-1].Cursor
	}
	return nil
}

func convertActivityUser(protoUser *authpb.User) *model.User {
	if protoUser != nil {
		return convertProtoUserToGraphQL(protoUser)
	}
	return nil
}

// Query returns generated.QueryResolver implementation.
func (r *Resolver) Query() generated.QueryResolver { return &queryResolver{r} }

type queryResolver struct{ *Resolver }
