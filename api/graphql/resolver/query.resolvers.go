package resolver

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.78

import (
	"context"
	"erp-api-gateway/api/graphql/generated"
	"erp-api-gateway/api/graphql/model"
	authpb "erp-api-gateway/proto/gen/auth"
	"fmt"
)

// Me is the resolver for the me field.
func (r *queryResolver) Me(ctx context.Context) (*model.User, error) {
	// Get user ID from context (set by auth middleware)
	userID, exists := ctx.Value("user_id").(string)
	if !exists {
		return nil, fmt.Errorf("user not authenticated")
	}

	// Use DataLoader to get user
	if dl := r.DataLoader; dl != nil {
		return dl.GetUser(ctx, userID)
	}

	// Fallback to direct gRPC call
	authClient, err := r.GRPCClient.AuthService(ctx)
	if err != nil {
		r.Logger.Error("Failed to get auth client", map[string]interface{}{
			"error":   err,
			"user_id": userID,
		})
		return nil, fmt.Errorf("authentication service unavailable")
	}

	resp, err := authClient.GetUser(ctx, &authpb.GetUserRequest{
		UserId: userID,
	})

	if err != nil {
		r.Logger.Error("Failed to get current user", map[string]interface{}{
			"error":   err,
			"user_id": userID,
		})
		return nil, fmt.Errorf("failed to get user information")
	}

	if !resp.Success {
		return nil, fmt.Errorf("failed to get user: %s", resp.Message)
	}

	return convertProtoUserToGraphQL(resp.Data), nil
}

// User is the resolver for the user field.
func (r *queryResolver) User(ctx context.Context, id string) (*model.User, error) {
	// Check if user has admin permission
	userClaims := ctx.Value("user_claims")
	if userClaims == nil {
		return nil, fmt.Errorf("user not authenticated")
	}

	// TODO: Implement proper RBAC check for admin permission
	// For now, just check if user is authenticated

	// Use DataLoader to get user
	if dl := r.DataLoader; dl != nil {
		return dl.GetUser(ctx, id)
	}

	// Fallback to direct gRPC call
	authClient, err := r.GRPCClient.AuthService(ctx)
	if err != nil {
		r.Logger.Error("Failed to get auth client", map[string]interface{}{
			"error":   err,
			"user_id": id,
		})
		return nil, fmt.Errorf("authentication service unavailable")
	}

	resp, err := authClient.GetUser(ctx, &authpb.GetUserRequest{
		UserId: id,
	})

	if err != nil {
		r.Logger.Error("Failed to get user", map[string]interface{}{
			"error":   err,
			"user_id": id,
		})
		return nil, fmt.Errorf("failed to get user information")
	}

	if !resp.Success {
		return nil, fmt.Errorf("user not found")
	}

	return convertProtoUserToGraphQL(resp.Data), nil
}

// Users is the resolver for the users field.
func (r *queryResolver) Users(ctx context.Context, limit *int, offset *int, search *string) ([]*model.User, error) {
	// Check if user has admin permission
	userClaims := ctx.Value("user_claims")
	if userClaims == nil {
		return nil, fmt.Errorf("user not authenticated")
	}

	// TODO: Implement proper RBAC check for admin permission
	// For now, return empty list as this would require a new gRPC method

	r.Logger.Info("Users query called", map[string]interface{}{
		"limit":       limit,
		"offset":      offset,
		"search":      search,
		"user_claims": userClaims,
	})

	// This would require implementing a ListUsers gRPC method in the auth service
	// For now, return empty list
	return []*model.User{}, nil
}

// Roles is the resolver for the roles field.
func (r *queryResolver) Roles(ctx context.Context) ([]*model.Role, error) {
	// Check if user has admin permission
	userClaims := ctx.Value("user_claims")
	if userClaims == nil {
		return nil, fmt.Errorf("user not authenticated")
	}

	// TODO: Implement proper RBAC check for admin permission
	// This would require implementing a ListRoles gRPC method in the auth service
	// For now, return empty list

	r.Logger.Info("Roles query called", map[string]interface{}{
		"user_claims": userClaims,
	})

	return []*model.Role{}, nil
}

// Permissions is the resolver for the permissions field.
func (r *queryResolver) Permissions(ctx context.Context) ([]*model.Permission, error) {
	// Check if user has admin permission
	userClaims := ctx.Value("user_claims")
	if userClaims == nil {
		return nil, fmt.Errorf("user not authenticated")
	}

	// TODO: Implement proper RBAC check for admin permission
	// This would require implementing a ListPermissions gRPC method in the auth service
	// For now, return empty list

	r.Logger.Info("Permissions query called", map[string]interface{}{
		"user_claims": userClaims,
	})

	return []*model.Permission{}, nil
}

// Health is the resolver for the health field.
func (r *queryResolver) Health(ctx context.Context) (string, error) {
	return "OK", nil
}

// Query returns generated.QueryResolver implementation.
func (r *Resolver) Query() generated.QueryResolver { return &queryResolver{r} }

type queryResolver struct{ *Resolver }
